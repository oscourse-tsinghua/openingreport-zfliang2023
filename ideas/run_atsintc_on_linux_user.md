
## 在 Linux 用户态使用 `ATSINTC` 方案

目的：使用 `ATSINTC` 来处理中断，使得用户态使用外设不需要通过轮循，从而提高 CPU 利用率

可行性分析：

1. 目前 `ATSINTC` 的实现是没有与内存进行交互，所有的任务直接存放在硬件中，因此在用户态只需要访问 `ATSINTC` 的 MMIO 接口即可实现任务调度
   1. 由于任务数量过多，必须把一些任务放到内存中。此时，`ATSINTC` 需要记录当前进程在内存中维护的调度队列区域的指针，初始化这个内存区域的过程应该在内核中进行，因此，在硬件中记录的也应该是内存区域的物理地址。一旦硬件中的队列达到容量限制后，它会自动将任务放置到内存的队列中，因此不存在由于特权级导致的内存访问问题，能够直接在用户态使用 `ATSINTC` 的任务调度功能
2. `ATSINTC` 直接连接到外设的中断信号线上，不会向 CPU 发送中断，没有与 CPU 的特权级相关，因此无论 CPU 处于何种状态，都能对中断进行处理，直接唤醒硬件内阻塞的协程，并且这个阻塞的任务数量不会很多，一个外设对应一个阻塞任务即可
3. 目前只考虑把 `ATSINTC` 给单个进程使用，多进程之间的访问权限控制还需要在内核中进行额外的设计

目前存在的困难：

1. 对于 linux 的调研不充分
    1. 在用户态使用外设的调研不够，可以把外设和 `ATSINTC` 的 MMIO 内存区域映射到用户态地址空间中，这样可以对外设进行控制，但由于 DMA 需要操作物理地址，目前的网卡驱动没有将虚拟地址转化成物理地址的能力。
    2. 可能的解决方案是直接运行没有 MMU 的 linux，但是调研也不充分。
2. 在用户态使用 `ATSINTC` 以及网卡，也是只能进行基础的驱动测试，要进行其他的真实负载测试，跑真实应用，需要的开发时间太多了
