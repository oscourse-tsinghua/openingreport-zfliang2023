### 软硬件结合的共享调度器设计方案V1

#### 最终目标

操作系统以及应用程序中的任务都以协程的形式存在，软硬件进行配合，保证除了协程本身主动让权情形外，在中断和异常发生时，减少（甚至消除）特权级以及上下文切换的开销，完全异步的进行中断和异常处理。



#### 性能指标

1. 系统整体的性能（可能的测试是故意让某个协程产生缺页异常（这个可以找到现成的 benchmark），统计应用程序运行的时间，突出只要有就绪协程（任务）存在，CPU 就不会空闲）
2. 减少 IPC 开销



#### 实施方案

1. 硬件实现（==**硬件对于上下文切换的处理，需要能够在任何时刻，对正在执行的协程插入 leaf-future，进行协程切换**==）
    1. 在硬件共享调度器内集成调度机制，对协程优先级进行管理（利用硬件内部的寄存器与 DRAM 配合进行，与 TKF uintr 的设计类似），可以针对这部分进行 microbench 测试，统计开销
    2. 硬件共享调度器继承或完善 TKF 的 uintr 实现（也可以不进行这个步骤，不使用用户态中断）
    3. 将 plic 连接在硬件共享调度器上（或者参考 plic 的实现，外部中断信号不经过 plic，直接由硬件共享调度器处理）
    4. 将软件中断、时钟中断和异常的信号线连接到硬件共享调度器上，由硬件共享调度器进行最开始的中断、异常处理
    5. 硬件共享调度器对异步系统调用、中断、异常进行处理
        1. 时钟中断：上下文切换
        2. 外部中断：硬件上将提前注册的中断处理协程加入到硬件的就绪队列中，如果存在其他空闲的 CPU，则对于正在当前 CPU 上执行的协程没有任何干扰；如果都不存在空闲 CPU，则发出信号给当前 CPU，通知 CPU 保存当前协程上下文，并进行抢占（保证及时响应）
        3. 软件中断：上下文切换
        4. 异步系统调用（ecall）：与外部中断的处理类似，硬件缓存系统调用的参数，等其他 CPU 处于内核态时，从缓存队列中取出系统调用信息创建内核协程（可以通过设置时间参数进行强制抢占其他的 CPU 陷入内核做出响应）
        5. 用户态中断：将接收方注册的用户态中断处理协程加入就绪队列，并且对正在执行的协程插入 leaf-future
2. 软件实现
    1. 自定义进程、线程上下文 ctx（context），对这两个 ctx 实现 future trait，在 poll 函数中进行上下文切换，通过 await 关键字进行协程、线程、进程切换。==硬件如果能够做到在协程的任何位置插入 leaf-future，那么可以将协程不能及时响应的缺点消除==
    2. 能够兼容 linux 应用（redis、sqlite、nginx 等）的内核实现，用于最终性能指标测试，在 linux 中进行不现实（不确定）





#### 目前的进展

1. 利用 await 进行上下文切换可行，在软件上可以利用 await 将协程、线程、进程上下文切换统一起来，因此 await 的语义出现了变化，针对进程/线程，await 变成了同步等待，等待执行完毕后，切换到下一个协程进行处理，针对普通的协程，await 语义不变，仍然为异步等待
2. 学习了 embassy 的 executor 实现后，中断与 core::task::Context、core::task::Waker 之间的关系可以紧密结合起来（暂时还不明白）







