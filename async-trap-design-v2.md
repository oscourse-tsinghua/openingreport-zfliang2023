#### AsyncTrap 设计文档

##### 目标：提供快速的上下文切换，以及关于系统调用、中断、异常的异步路径


##### 处理流程

```mermaid
flowchart LR
  entry
  partial_save
  handler
  entire_save
  return

entry --> partial_save --> handler --> entire_save --> return
handler --> return
```

大致的处理流程如上图所示。需要明确其中几个关键的问题：

- `entry` 作为控制流转移（除协程切换）的入口。进入之后，所有的寄存器现场仍然保持被打断时的状态。
- `handler` 是快速路径函数，用 `Rust` 语言来实现。而 `RISC-V` 的函数调用规范规定了 `callee` 保存 `s0 ~ s11` 这些寄存器，因此，在 `partial_save` 中只需要保存 `caller` 需要保存的寄存器即可。并且作为控制流转移的入口，其中参数寄存器 `a0 ~ a7` 寄存器不需要保存，可能作为控制流转移的原因，必要时在 `entire_save` 阶段保存。故 `partial_save` 阶段只需要保存 `ra, t0 ~ t6` 即可。
- `handler` 函数处理根据不同的原因进行不同的处理，最后的结果分类
  - 直接返回被打断的控制流（外部中断、异步系统调用），在 `handler` 阶段唤醒中断分发协程、系统调用分发协程
  - 切换到同一地址空间内的控制流（缺页异常），在 `handler` 阶段唤醒异常处理协程
  - 切换到不同地址空间的控制流（时钟中断、其他异常、同步系统调用）

上述的部分寄存器现场需要一个位置保存。

目前的硬件：除了用户态中断，其他的控制流变化，一定是处于 `Supervisor` 模式。若要将上下文保存在被打断的控制流的栈顶，那么在从用户态陷入时，切换了特权级，会导致用户态的栈不可用。`partial_save` 阶段保存的寄存器的位置应该选择在哪？
`FastTrap` 将其保存在内核栈中，这导致了用户态协程被打断后，对应的协程与内核栈绑定了，而不是与用户态的栈绑定。这是不符合逻辑的。这里需要将上下文保存在用户态正在使用的栈上。

内核调度到进程时，跳转到用户态，这个过程发生在协程执行过程中，相当于这个协程被打断了，此时将上下文保存在栈中，相当于内核协程与这个内核栈绑定，与上述的用户态协程被打断与用户栈绑定相关。那么之前分析的 `await` 语义变化也就不存在了。

基于这样的分析，可以从软件上，利用虚拟地址机制，将用户态使用的栈的物理地址映射到两个不同的虚拟地址，一个用于在 `User` 模式下访问，另一个在 `Supervisor` 模式下。在汇编代码中只需要进行位运算即可切换虚拟地址。另外，还可以在 `sstatus` 寄存器中设置 `sum` 位置，让 `Supervisor` 模式可以访问带有 `U` 标记的页表。通过这种方式不需要切换栈。

上下文直接保存在栈上。
